#include "globals.h"

/* these globals are written by interrupt service routines; we have to declare 
 * these as volatile to avoid the compiler caching their values in registers */
extern volatile unsigned char byte1, byte2, byte3;	/* modified by PS/2 interrupt service routine */
extern volatile int timeout;								// used to synchronize with the timer
extern struct alt_up_dev up_dev;							/* pointer to struct that holds pointers to
																		open devices */
extern volatile int buf_index_record, buf_index_play;


extern short cursor_shape[16][8];

/* Constants */
#define X_BOUND 319
#define Y_BOUND 239

/* Global Variables */
	signed short x_axis_mouse = 160, y_axis_mouse = 120; // Current axises of mouse
	unsigned char command; //Which button clicked by mouse
	unsigned int l_buf[BUF_SIZE];					// audio buffer
	unsigned int r_buf[BUF_SIZE];					// audio buffer
	unsigned int l_buf_echo[BUF_SIZE];				// audio echo buffer
	unsigned int r_buf_echo[BUF_SIZE];				// audio echo buffer


short cursor_shape[16][8] = {
  { 0, -1, -1, -1, -1, -1, -1, -1},
  { 0,  0, -1, -1, -1, -1, -1, -1},
  { 0,  1,  0, -1, -1, -1, -1, -1},
  { 0,  1,  1,  0, -1, -1, -1, -1},
  { 0,  1,  1,  1,  0, -1, -1, -1},
  { 0,  1,  1,  1,  1,  0, -1, -1},
  { 0,  1,  1,  1,  1,  1,  0, -1},
  { 0,  1,  1,  1,  1,  0,  0,  0},
  { 0,  1,  1,  1,  0, -1, -1, -1},
  { 0,  0,  0,  1,  0, -1, -1, -1},
  { 0, -1,  0,  1,  0, -1, -1, -1},
  {-1, -1, -1,  0,  1,  0, -1, -1},
  {-1, -1, -1,  0,  1,  0, -1, -1},
  {-1, -1, -1, -1,  0,  1,  0, -1},
  {-1, -1, -1, -1,  0,  1,  0, -1},
  {-1, -1, -1, -1, -1,  0, -1, -1}
};

/* function prototypes */
// void HEX_PS2(unsigned char, unsigned char, unsigned char);
void interval_timer_ISR(void *, unsigned int);
void pushbutton_ISR(void *, unsigned int);
void audio_ISR(void *, unsigned int);
void PS2_ISR(void *, unsigned int);
void Mouse_ISR (struct alt_up_dev *, unsigned char, unsigned char, unsigned char,
				signed short x_axis_mouse, signed short y_axis_mouse);
void setMouseBounds(signed short x_axis_mouse, signed short y_axis_mouse,
					unsigned char info, unsigned char x_move, unsigned char y_move);
unsigned char command_det(unsigned char buttons_stat);
void run_command(struct alt_up_dev *up_dev, unsigned char command);
void make_echo(void);

/********************************************************************************
 * This program demonstrates use of the media ports in the DE2 Media Computer
 *
 * It performs the following: 
 *  	1. records audio for about 10 seconds when an interrupt is generated by
 *  	   pressing KEY[1]. LEDG[0] is lit while recording. Audio recording is 
 *  	   controlled by using interrupts
 * 	2. plays the recorded audio when an interrupt is generated by pressing
 * 	   KEY[2]. LEDG[1] is lit while playing. Audio playback is controlled by 
 * 	   using interrupts
 * 	3. Draws a blue box on the VGA display, and places a text string inside
 * 	   the box. Also, moves the word ALTERA around the display, "bouncing" off
 * 	   the blue box and screen edges
 * 	4. Shows a text message on the LCD display, and scrolls the message
 * 	5. Displays the last three bytes of data received from the PS/2 port 
 * 	   on the HEX displays on the DE2 board. The PS/2 port is handled using 
 * 	   interrupts
 * 	6. The speed of scrolling the LCD display and of refreshing the VGA screen
 * 	   are controlled by interrupts from the interval timer
********************************************************************************/
int main(void)
{
	signed short pre_x_axis_mouse, pre_y_axis_mouse;

	/* declare device driver pointers for devices */
	alt_up_parallel_port_dev *KEY_dev;
	alt_up_parallel_port_dev *green_LEDs_dev;
	alt_up_parallel_port_dev *red_LEDs_dev;
	alt_up_ps2_dev *PS2_dev;
	alt_up_character_lcd_dev *lcd_dev;
	alt_up_audio_dev *audio_dev;
	alt_up_char_buffer_dev *char_buffer_dev;
	alt_up_pixel_buffer_dma_dev *pixel_buffer_dev;
	/* declare volatile pointer for interval timer, which does not have HAL functions */
	volatile int * interval_timer_ptr = (int *) 0x10002000;	// interal timer base address

	/* initialize some variables */
	byte1 = 0; byte2 = 0; byte3 = 0; 			// used to hold PS/2 data
	timeout = 0;										// synchronize with the timer

	/* these variables are used for a blue box and a "bouncing" ALTERA on the VGA screen */
	int ALT_x1; int ALT_x2; int ALT_y; 
	int ALT_inc_x; int ALT_inc_y;
	int blue_x1; int blue_y1; int blue_x2; int blue_y2; 
	int screen_x; int screen_y; int char_buffer_x; int char_buffer_y;
	short color;
	int record_box_x1, record_box_x2, record_box_y1, record_box_y2;
	int play_box_x1, play_box_x2, play_box_y1, play_box_y2;
	int echo_box_x1, echo_box_x2, echo_box_y1, echo_box_y2;

	/* set the interval timer period for scrolling the HEX displays */
	int counter = 0x960000;				// 1/(50 MHz) x (0x960000) ~= 200 msec
	*(interval_timer_ptr + 0x2) = (counter & 0xFFFF);
	*(interval_timer_ptr + 0x3) = (counter >> 16) & 0xFFFF;

	/* start interval timer, enable its interrupts */
	*(interval_timer_ptr + 1) = 0x7;	// STOP = 0, START = 1, CONT = 1, ITO = 1 
	
	// open the pushbuttom KEY parallel port
	KEY_dev = alt_up_parallel_port_open_dev ("/dev/Pushbuttons");
	if ( KEY_dev == NULL)
	{
		alt_printf ("Error: could not open pushbutton KEY device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened pushbutton KEY device\n");
		up_dev.KEY_dev = KEY_dev;	// store for use by ISRs
	}
	/* write to the pushbutton interrupt mask register, and set 3 mask bits to 1 
	 * (bit 0 is Nios II reset) */
	alt_up_parallel_port_set_interrupt_mask (KEY_dev, 0xE);

	// open the green LEDs parallel port
	green_LEDs_dev = alt_up_parallel_port_open_dev ("/dev/Green_LEDs");
	if ( green_LEDs_dev == NULL)
	{
		alt_printf ("Error: could not open green LEDs device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened green LEDs device\n");
		up_dev.green_LEDs_dev = green_LEDs_dev;	// store for use by ISRs
	}

	// open the red LEDs parallel port
	red_LEDs_dev = alt_up_parallel_port_open_dev ("/dev/Red_LEDs");
	if ( red_LEDs_dev == NULL)
	{
		alt_printf ("Error: could not open red LEDs device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened red LEDs device\n");
		up_dev.red_LEDs_dev = red_LEDs_dev;	// store for use by ISRs
	}


	// open the PS2 port
	PS2_dev = alt_up_ps2_open_dev ("/dev/PS2_Port");
	if ( PS2_dev == NULL)
	{
		alt_printf ("Error: could not open PS2 device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened PS2 device\n");
		up_dev.PS2_dev = PS2_dev;	// store for use by ISRs
	}
	(void) alt_up_ps2_write_data_byte (PS2_dev, 0xFF);		// reset
	alt_up_ps2_enable_read_interrupt (PS2_dev); // enable interrupts from PS/2 port

	// open the audio port
	audio_dev = alt_up_audio_open_dev ("/dev/Audio");
	if ( audio_dev == NULL)
	{
		alt_printf ("Error: could not open audio device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened audio device\n");
		up_dev.audio_dev = audio_dev;	// store for use by ISRs
	}

	// open the 16x2 character display port
	lcd_dev = alt_up_character_lcd_open_dev ("/dev/Char_LCD_16x2");
	if ( lcd_dev == NULL)
	{
		alt_printf ("Error: could not open character LCD device\n");
		return -1;
	}
	else
	{
		alt_printf ("Opened character LCD device\n");
		up_dev.lcd_dev = lcd_dev;	// store for use by ISRs
	}

	/* use the HAL facility for registering interrupt service routines. */
	/* Note: we are passsing a pointer to up_dev to each ISR (using the context argument) as 
	 * a way of giving the ISR a pointer to every open device. This is useful because some of the
	 * ISRs need to access more than just one device (e.g. the pushbutton ISR accesses both
	 * the pushbutton device and the audio device) */
	alt_irq_register (0, (void *) &up_dev, (void *) interval_timer_ISR);
	alt_irq_register (1, (void *) &up_dev, (void *) pushbutton_ISR);
	alt_irq_register (6, (void *) &up_dev, (void *) audio_ISR);
	alt_irq_register (7, (void *) &up_dev, (void *) PS2_ISR);

	/* create a messages to be displayed on the VGA and LCD displays */
	char text_top_LCD[80] = "Welcome to the DE2 Media Computer...\0";
	char text_top_VGA[20] = "Altera DE2\0";
	char text_bottom_VGA[20] = "Media Computer\0";
	char text_ALTERA[10] = "SAEED\0";
	char text_erase[10] = "      \0";
	char text_echo[10] = "Echo\0";
	char text_play[10] = "Play\0";
	char text_record[10] = "Record\0";


	/* output text message to the LCD */
	alt_up_character_lcd_set_cursor_pos (lcd_dev, 0, 0);	// set LCD cursor location to top row
	alt_up_character_lcd_string (lcd_dev, text_top_LCD);
	alt_up_character_lcd_cursor_off (lcd_dev);				// turn off the LCD cursor 

	/* open the pixel buffer */
	pixel_buffer_dev = alt_up_pixel_buffer_dma_open_dev ("/dev/VGA_Pixel_Buffer");
	if ( pixel_buffer_dev == NULL)
		alt_printf ("Error: could not open pixel buffer device\n");
	else
		alt_printf ("Opened pixel buffer device\n");

	/* the following variables give the size of the pixel buffer */
	screen_x = 319; screen_y = 239;
	color = 0x5550;		// a dark grey color
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, 0, 0, screen_x, 
		screen_y, color, 0); // fill the screen


	
	// // draw a medium-blue box in the middle of the screen, using character buffer coordinates
	// blue_x1 = 28; blue_x2 = 52; blue_y1 = 26; blue_y2 = 34;
	// // character coords * 4 since characters are 4 x 4 pixel buffer coords (8 x 8 VGA coords)
	// color = 0x187F;		// a medium blue color
	// alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, blue_x1 * 4, blue_y1 * 4, blue_x2 * 4, 
	// 	blue_y2 * 4, color, 0);

	/* output text message in the middle of the VGA monitor */
	char_buffer_dev = alt_up_char_buffer_open_dev ("/dev/VGA_Char_Buffer");
	if ( char_buffer_dev == NULL)
		alt_printf ("Error: could not open character buffer device\n");
	else
		alt_printf ("Opened character buffer device\n");

	// alt_up_char_buffer_string (char_buffer_dev, text_top_VGA, blue_x1 + 5, blue_y1 + 3);
	// alt_up_char_buffer_string (char_buffer_dev, text_bottom_VGA, blue_x1 + 5, blue_y1 + 4);
	
	// char_buffer_x = 79; char_buffer_y = 59;
	// ALT_x1 = 0; ALT_x2 = 5/* ALTERA = 6 chars */; ALT_y = 0; ALT_inc_x = 1; ALT_inc_y = 1;
	// alt_up_char_buffer_string (char_buffer_dev, text_ALTERA, ALT_x1, ALT_y);

	/* this loops "bounces" the word ALTERA around on the VGA screen */



while (1)
	{
	// Place your code here
	record_box_x1 = 35; record_box_x2 = 100; record_box_y1 = 92; record_box_y2 = 136;
	// character coords * 4 since characters are 4 x 4 pixel buffer coords (8 x 8 VGA coords)
	color = 0x6F00;		// a bad yellow color
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, record_box_x1, record_box_y1,
									  record_box_x2, record_box_y2, color, 0);
	play_box_x1 = 125; play_box_x2 = 190; play_box_y1 = 92; play_box_y2 = 136;
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, play_box_x1, play_box_y1,
									  play_box_x2, play_box_y2, color, 0);
	echo_box_x1 = 215; echo_box_x2 = 280; echo_box_y1 = 92; echo_box_y2 = 136;
	alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, echo_box_x1, echo_box_y1,
									  echo_box_x2, echo_box_y2, color, 0);
	

	alt_up_char_buffer_string (char_buffer_dev, text_record, 14, 28);
	alt_up_char_buffer_string (char_buffer_dev, text_play, 37, 28);
	alt_up_char_buffer_string (char_buffer_dev, text_echo, 60, 28);
	


	//End of your code here





	
		
		while (!timeout)
			;	// wait to synchronize with timeout, which is set by the interval timer ISR 

		/* move the ALTERA text around on the VGA screen */
		// alt_up_char_buffer_string (char_buffer_dev, text_erase, ALT_x1, ALT_y); // erase
		// ALT_x1 += ALT_inc_x; 
		// ALT_x2 += ALT_inc_x; 
		// ALT_y += ALT_inc_y;

		// if ( (ALT_y == char_buffer_y) || (ALT_y == 0) )
		// 	ALT_inc_y = -(ALT_inc_y);
		// if ( (ALT_x2 == char_buffer_x) || (ALT_x1 == 0) )
		// 	ALT_inc_x = -(ALT_inc_x);

		// if ( (ALT_y >= blue_y1 - 1) && (ALT_y <= blue_y2 + 1) )
		// {
		// 	if ( ((ALT_x1 >= blue_x1 - 1) && (ALT_x1 <= blue_x2 + 1)) ||
		// 		((ALT_x2 >= blue_x1 - 1) && (ALT_x2 <= blue_x2 + 1)) )
		// 	{
		// 		if ( (ALT_y == (blue_y1 - 1)) || (ALT_y == (blue_y2 + 1)) )
		// 			ALT_inc_y = -(ALT_inc_y);
		// 		else
		// 			ALT_inc_x = -(ALT_inc_x);
		// 	}
		// }
		// alt_up_char_buffer_string (char_buffer_dev, text_ALTERA, ALT_x1, ALT_y);

		/* also, display any PS/2 data (from its interrupt service routine) on HEX displays */
		// HEX_PS2 (byte1, byte2, byte3);


		
		
		Mouse_ISR (&up_dev, byte1, byte2, byte3, x_axis_mouse, y_axis_mouse);
		byte1 = 0;
		byte2 = 0;
		byte3 = 0;
		
		color = 0x5550;
		alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, pre_x_axis_mouse - 2, pre_y_axis_mouse - 2,
										pre_x_axis_mouse + 2, pre_y_axis_mouse + 2, color, 0);
		short color = 0xFFFF;		// a White color
		alt_up_pixel_buffer_dma_draw_box (pixel_buffer_dev, x_axis_mouse - 2, y_axis_mouse - 2,
										x_axis_mouse + 2, y_axis_mouse + 2, color, 0);

		pre_x_axis_mouse = x_axis_mouse;
		pre_y_axis_mouse = y_axis_mouse;

		command = command_det(byte1); // 0:record, 1:play, 2:echo
		run_command(&up_dev, command);
		

		timeout = 0;
	}

}
void setMouseBounds(signed short x_axis_mouse, signed short y_axis_mouse,
					unsigned char info, unsigned char x_move, unsigned char y_move) {
	
	signed short x_move_s = x_move, y_move_s = y_move;
	

	if((info >> 6) & 0x01){ // x overflow = 1
		if((info >> 4) & 0x01)
			x_axis_mouse += (-255 + x_move_s) / 3;
		else
			x_axis_mouse += (+255 + x_move_s) / 3;
	}
	else // x overflow = 0
		x_axis_mouse += x_move_s / 3;

	if((info >> 7) & 0x01){ // y overflow = 1
		if((info >> 5) & 0x01)
			y_axis_mouse -= (-255 + y_move_s) / 3;
		else
			y_axis_mouse -= (+255 + y_move_s) / 3;
	}
	else // y overflow = 0
		y_axis_mouse -= y_move_s / 3;

	char buf [100];

	//Debugging start
	sprintf(buf, "x_move_s: %d\n", (int) x_move_s);
	alt_printf(buf);
	sprintf(buf, "y_move_s: %d\n", (int) y_move_s);
	alt_printf(buf);

	sprintf(buf, "x_axis_mouse: %d\n", (int) x_axis_mouse);
	alt_printf(buf);
	sprintf(buf, "y_axis_mouse: %d\n", (int) y_axis_mouse);
	alt_printf(buf);
	//Debugging end



	if(x_axis_mouse < 2) x_axis_mouse = 2;
	if(x_axis_mouse > X_BOUND - 2) x_axis_mouse = X_BOUND - 2;
	if(y_axis_mouse < 2) y_axis_mouse = 2;
	if(y_axis_mouse > Y_BOUND - 2) y_axis_mouse = Y_BOUND - 2;
}


void Mouse_ISR (struct alt_up_dev *up_dev, unsigned char b1, unsigned char b2, unsigned char b3,
				signed short x_axis_mouse, signed short y_axis_mouse) {
	volatile int *HEX3_HEX0_ptr = (int *) 0x10000020;
	volatile int *HEX7_HEX4_ptr = (int *) 0x10000030;
	unsigned char hex_segs[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	unsigned char button_mouse[3];

	unsigned char	seven_seg_decode_table[] = {	0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 
											0x7F, 0x67, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71 };


	alt_up_parallel_port_write_data (up_dev->red_LEDs_dev, 0); // Turn off LEDRs
	
	if(b1 & 0x01){
		alt_up_parallel_port_write_data (up_dev->red_LEDs_dev, 0x1);/*LED0 -> Left btn*/
	}
	else if(b1 & 0x02){
		alt_up_parallel_port_write_data (up_dev->red_LEDs_dev, 0x2);/*LED1 -> Right btn*/
	}
	else if(b1 & 0x04){
		alt_up_parallel_port_write_data (up_dev->red_LEDs_dev, 0x4);/*LED2 -> Middle btn*/
	}

	hex_segs[0] = seven_seg_decode_table [b3 & 0x0F];
	hex_segs[1] = seven_seg_decode_table [(b3 >> 4) & 0x0F];
	hex_segs[2] = seven_seg_decode_table[b1 >> 7 & 0x01];
	hex_segs[3] = seven_seg_decode_table[b1 >> 5 & 0x01];

	hex_segs[4] = seven_seg_decode_table [b2 & 0x0F];
	hex_segs[5] = seven_seg_decode_table [(b2 >> 4) & 0x0F];
	hex_segs[6] = seven_seg_decode_table[b1 >> 6 & 0x01];
	hex_segs[7] = seven_seg_decode_table[b1 >> 4 & 0x01];

	*(HEX3_HEX0_ptr) = *(int *) (hex_segs);
	*(HEX7_HEX4_ptr) = *(int *) (hex_segs+4);

	setMouseBounds(x_axis_mouse, y_axis_mouse, b1, b2, b3);


}

/****************************************************************************************
 * Subroutine to show a string of HEX data on the HEX displays
 * Note that we are using pointer accesses for the HEX displays parallel port. We could
 * also use the HAL functions for these ports instead
****************************************************************************************/
// void HEX_PS2(unsigned char b1, unsigned char b2, unsigned char b3)
// {
// 	volatile int *HEX3_HEX0_ptr = (int *) 0x10000020;
// 	volatile int *HEX7_HEX4_ptr = (int *) 0x10000030;

// 	/* SEVEN_SEGMENT_DECODE_TABLE gives the on/off settings for all segments in 
// 	 * a single 7-seg display in the DE2 Media Computer, for the hex digits 0 - F */
// 	unsigned char	seven_seg_decode_table[] = {	0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 
// 		  										0x7F, 0x67, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71 };
// 	unsigned char	hex_segs[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
// 	unsigned int shift_buffer, nibble;
// 	unsigned char code;
// 	int i;

// 	shift_buffer = (b1 << 16) | (b2 << 8) | b3;
// 	for ( i = 0; i < 6; ++i )
// 	{
// 		nibble = shift_buffer & 0x0000000F;		// character is in rightmost nibble
// 		code = seven_seg_decode_table[nibble];
// 		hex_segs[i] = code;
// 		shift_buffer = shift_buffer >> 4;
// 	}
// 	/* drive the hex displays */
// 	*(HEX3_HEX0_ptr) = *(int *) (hex_segs);
// 	*(HEX7_HEX4_ptr) = *(int *) (hex_segs+4);
// }






void make_echo(){
	int i;
	for (i = 5000; i < BUF_SIZE; i++){
		l_buf_echo[i] = l_buf[i - 5000] + l_buf[i - 1000];
		r_buf_echo[i] = r_buf[i - 5000] + r_buf[i - 1000];
	}
}


void run_command(struct alt_up_dev *up_dev, unsigned char command) {
	int num_read;
	int num_written;
	if(command == 0){ //Record
		if (buf_index_record < BUF_SIZE)
		{
			num_read = alt_up_audio_record_r (up_dev->audio_dev, &(r_buf[buf_index_record]), 
				BUF_SIZE - buf_index_record);
			/* assume we can read same # words from the left and right */
			(void) alt_up_audio_record_l (up_dev->audio_dev, &(l_buf[buf_index_record]), 
				num_read);
			buf_index_record += num_read;

			if (buf_index_record == BUF_SIZE)
			{
				// done recording
				alt_up_parallel_port_write_data (up_dev->green_LEDs_dev, 0); // turn off LEDG
				alt_up_audio_disable_read_interrupt(up_dev->audio_dev);
			}
		}
		make_echo();
	}
	if(command == 1){ //Play
		// output data until the buffer is empty 
		if (buf_index_play < BUF_SIZE)
		{
			num_written = alt_up_audio_play_r (up_dev->audio_dev, &(r_buf[buf_index_play]), 
			 	BUF_SIZE - buf_index_play);
			/* assume that we can write the same # words to the left and right */
			(void) alt_up_audio_play_l (up_dev->audio_dev, &(l_buf[buf_index_play]), 
				num_written);
			buf_index_play += num_written;
	
			if (buf_index_play == BUF_SIZE)
			{
				// done playback
				alt_up_parallel_port_write_data (up_dev->green_LEDs_dev, 0); // turn off LEDG
				alt_up_audio_disable_write_interrupt(up_dev->audio_dev);
			}
		}
	}
	if(command == 2){ //Echo
		if (buf_index_play < BUF_SIZE)
		{
			num_written = alt_up_audio_play_r (up_dev->audio_dev, &(r_buf_echo[buf_index_play]), 
			 	BUF_SIZE - buf_index_play);
			/* assume that we can write the same # words to the left and right */
			(void) alt_up_audio_play_l (up_dev->audio_dev, &(l_buf_echo[buf_index_play]), 
				num_written);
			buf_index_play += num_written;
	
			if (buf_index_play == BUF_SIZE)
			{
				// done playback
				alt_up_parallel_port_write_data (up_dev->green_LEDs_dev, 0); // turn off LEDG
				alt_up_audio_disable_write_interrupt(up_dev->audio_dev);
			}
		}
	}
}

unsigned char command_det(unsigned char buttons_stat) {
	if((buttons_stat >> 0) % 2){
		if(x_axis_mouse >= 35 && x_axis_mouse <= 100 &&
		   y_axis_mouse >= 92 && y_axis_mouse <= 136)
			return 0;
		else if(x_axis_mouse >= 125 && x_axis_mouse <= 190 &&
				y_axis_mouse >= 92 && y_axis_mouse <= 136)
			return 1;
		else if(x_axis_mouse >= 215 && x_axis_mouse <= 280 &&
				y_axis_mouse >= 92 && y_axis_mouse <= 136)
			return 2;
	}
	return -1;
}

void draw_mouse(struct alt_up_dev *up_dev){
	int i,j;
	for(j=0;j<8;j++){//clear previous mouse cursor
		for(i=0;i<16;i++){
			if(cursor_shape[i][j]!= -1)
				alt_up_pixel_buffer_dma_draw(up_dev->pixel_buffer_dev,0,x_axis_mouse+j, y_axis_mouse+i);
		}
	}

	//mouseLocation(byte1,byte2,byte3);//calculates the location of the mouse cursor in the screen

	for(j=0;j<8;j++){//print mouse cursor
		for(i=0;i<16;i++){
			if(cursor_shape[i][j]!= -1)
				alt_up_pixel_buffer_dma_draw(up_dev->pixel_buffer_dev,cursor_shape[i][j]*(-1),x_axis_mouse+j, y_axis_mouse+i);
		}
	}
}